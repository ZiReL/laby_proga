#include <iostream>
#include <vector>

using namespace std;

class CPolynomial {
private:
    vector<float> polyn_;
public:

    CPolynomial() {
    };

    CPolynomial(vector<float> &mas) {
        polyn_ = mas;
    };

    CPolynomial(const CPolynomial &p)
            : polyn_(p.polyn_) {
    };

    CPolynomial &operator=(const CPolynomial &p) {
        if (&p == this)
            return *this;
        polyn_ = p.polyn_;
        return *this;
    };

    friend CPolynomial operator+(const CPolynomial &pl, const CPolynomial &pr) {
        vector<float> sum;
        if (pl.polyn_.size() >= pr.polyn_.size()) {
            sum = pl.polyn_;
            for (int i = 0; i < pr.polyn_.size(); i++)
                sum[i] += pr.polyn_[i];
        } else {
            sum = pr.polyn_;
            for (int i = 0; i < pl.polyn_.size(); i++)
                sum[i] += pl.polyn_[i];
        }
        return sum;
    };

    CPolynomial &operator+=(const CPolynomial &pr) {
        if (this->polyn_.size() >= pr.polyn_.size())
            for (int i = 0; i < pr.polyn_.size(); i++)
                this->polyn_[i] += pr.polyn_[i];
        else {
            vector<float> mas(this->polyn_);
            this->polyn_ = pr.polyn_;
            for (int i = 0; i < this->polyn_.size(); i++)
                this->polyn_[i] += mas[i];
        }
        return *this;
    };

    friend CPolynomial operator-(const CPolynomial &pl, const CPolynomial &pr) {
        vector<float> diff(pl.polyn_);
        if (pl.polyn_.size() < pr.polyn_.size())
            diff.resize(pr.polyn_.size());
        for (int i = 0; i < pr.polyn_.size(); i++)
            diff[i] -= pr.polyn_[i];
        return diff;
    };

    CPolynomial &operator-=(const CPolynomial &pr) {
        if (this->polyn_.size() < pr.polyn_.size())
            this->polyn_.resize(pr.polyn_.size());
        for (int i = 0; i < pr.polyn_.size(); i++)
            this->polyn_[i] -= pr.polyn_[i];
        return *this;
    };

    CPolynomial &operator-() {
        for (int i = 0; i < this->polyn_.size(); i++)
            this->polyn_[i] *= -1;
        return *this;
    };

    friend CPolynomial operator*(const CPolynomial &pl, const float &fl) {
        vector<float> comp;
        comp = pl.polyn_;
        for (int i = 0; i < pl.polyn_.size(); i++)
            comp[i] *= fl;
        return comp;
    };

    CPolynomial &operator*=(const float &fl) {
        for (int i = 0; i < this->polyn_.size(); i++)
            this->polyn_[i] *= fl;
        return *this;
    };

    friend CPolynomial operator*(const CPolynomial &pl, const CPolynomial &pr) {
        vector<float> comp(((pl.polyn_.size() - 1) + (pr.polyn_.size() - 1) + 1), 0);
        for (int i = 0; i < pl.polyn_.size(); i++)
            for (int j = 0; j < pr.polyn_.size(); j++) {
                if ((i != 0) and (j != 0))
                    comp[i + j] += pl.polyn_[i] * pr.polyn_[j];
                else {
                    if ((i == 0) and (j != 0))
                        comp[j] += pl.polyn_[0] * pr.polyn_[j];
                    else if ((j == 0) and (i != 0))
                        comp[i] += pl.polyn_[i] * pr.polyn_[0];
                    else
                        comp[0] += pl.polyn_[0] * pr.polyn_[0];
                }
            }
        return comp;
    };

    CPolynomial &operator*=(const CPolynomial &pr) {
        vector<float> vmas(this->polyn_);
        this->polyn_.resize(((vmas.size() - 1) + (pr.polyn_.size() - 1) + 1), 0);
        for (int i = 0; i < vmas.size(); i++)
            for (int j = 0; j < pr.polyn_.size(); j++) {
                if ((i != 0) and (j != 0))
                    this->polyn_[i + j] += vmas[i] * pr.polyn_[j];
                else {
                    if ((i == 0) and (j != 0))
                        this->polyn_[j] += vmas[0] * pr.polyn_[j];
                    else if ((j == 0) and (i != 0))
                        this->polyn_[i] += vmas[i] * pr.polyn_[0];
                    else
                        this->polyn_[0] += vmas[0] * pr.polyn_[0];
                }
            }
        return *this;
    };

    friend CPolynomial operator/(const CPolynomial &pl, const float &fl) {
        vector<float> comp;
        comp = pl.polyn_;
        for (int i = 0; i < pl.polyn_.size(); i++)
            comp[i] /= fl;
        return comp;
    };

    CPolynomial &operator/=(const float &fl) {
        for (int i = 0; i < this->polyn_.size(); i++)
            this->polyn_[i] /= fl;
        return *this;
    };

    float &operator[](const float &fl) {
        return this->polyn_[fl - 1];
    };

    friend bool operator==(const CPolynomial &pl, const CPolynomial &pr);

    friend bool operator!=(const CPolynomial &pl, const CPolynomial &pr);

    friend ostream &operator<<(ostream &stream, const CPolynomial &p);

    friend istream &operator>>(istream &cin, CPolynomial &p);

    ~CPolynomial() {
    };
};

bool operator==(const CPolynomial &pl, const CPolynomial &pr) {
    if (pl.polyn_.size() != pr.polyn_.size())
        return false;
    else
        for (int i = 0; i < pl.polyn_.size(); i++)
            if (pl.polyn_[i] != pr.polyn_[i])
                return false;
    return true;
};

bool operator!=(const CPolynomial &pl, const CPolynomial &pr) {
    return !(pl == pr);
};

ostream &operator<<(ostream &cout, const CPolynomial &p) {
    bool first = true;
    if (!p.polyn_.empty()) {
        for (int i = 0; i < p.polyn_.size(); i++)
            if (i == 0) {
                if (p.polyn_[0] != 0) {
                    cout << p.polyn_[0];
                    first = false;
                }
            }
            else {
                if (i == 1) {
                    if (p.polyn_[1] != 0) {
                        if (first) {
                            if (p.polyn_[1] > 0)
                                cout << p.polyn_[1] << 'x';
                            else
                                cout << p.polyn_[1] << 'x';
                            first = false;
                        } else if (p.polyn_[1] > 0)
                            cout << " + " << p.polyn_[1] << 'x';
                        else
                            cout << " - " << abs(p.polyn_[1]) << 'x';
                    }
                }
                else
                    if (p.polyn_[i] != 0) {
                        if (first) {
                            if (p.polyn_[i] > 0)
                                cout << p.polyn_[i] << "x^" << i;
                            else
                                cout << p.polyn_[i] << "x^" << i;
                            first = false;
                        } else if (p.polyn_[i] > 0)
                            cout << " + " << p.polyn_[i] << "x^" << i;
                        else
                            cout << " - " << abs(p.polyn_[i]) << "x^" << i;
                    }
            }
        if (first)
            cout << 0;
        cout << "\n";
    } else
        cout << 0 << "\n";
    return cout;
};

istream &operator>>(istream &cin, CPolynomial &p) {
    string str;
    getline(cin, str);
    str.erase(remove(str.begin(), str.end(), ' '), str.end());
    float coef = 0;
    int pow = 0;
    int sign_coef = 1;
    bool flag_coef = true;
    bool flag_pow = false;
    bool monom_ready = false;
    for (int i = 0; i < str.size(); i++) {
        if ((str[i] == '-') or (str[i] == '+')) {
            flag_coef = true;
            if (i == 0) {
                sign_coef = -1;
            }
        }
        else {
            if (str[i] == '^') {
                flag_pow = true;
            }
            else {
                if (str[i] == 'x') {

                }
                else {
                    if ((flag_coef) and (!flag_pow))
                        coef = coef * 10 + (str[i] - '0');
                    else {
                        if (flag_pow) {
                            pow = pow * 10 + (str[i] - '0');
                            monom_ready = true;
                        }
                    }
                }
            }
        }



        if (monom_ready) {
            monom_ready = false;
            p.polyn_.resize(pow + 1);
            p.polyn_[pow] = coef * sign_coef;
            flag_coef = false;
            flag_pow = false;
            coef = 0;
            pow = 0;
            sign_coef = 1;
        }
    }

    return cin;
}

int main() {

    vector<float> mas1 = {1, 2, 3};
    vector<float> mas2 = {1, 2, 3};
    vector<float> mas3 = {0, 2, 1};
    vector<float> mas4 = {3, 2, 5};

    CPolynomial p1;

    cin >> p1;

    cout << "\np1:\n";
    //CPolynomial p1(mas1);
    cout << p1;

    cout << "\np2:\n";
    CPolynomial p2(mas2);
    cout << p2;

    cout << "\np3:\n";
    CPolynomial p3(mas3);
    cout << p3;

    cout << "\np4:\n";
    CPolynomial p4(mas4);
    cout << p4;

    if (p1 == p2)
        cout << "p1 == p2\n";
    else
        cout << "p1 != p2\n";

    if (p1 != p3)
        cout << "p1 != p3\n";
    else
        cout << "p1 == p3\n";

    cout << "\n=\n";
    p3 = p1;
    cout << p3;

    cout << "\n+\n";
    p3 = p1 + p2;
    cout << p3;

    cout << "\n+=\n";
    p3 += p1;
    cout << p3;

    cout << "\n-(b)\n";
    p4 = p1 - p2;
    cout << p4;

    cout << "\n-(y)\n" << -p4;

    cout << "\n-=\n";
    p4 -= p1;
    cout << p4;

    cout << "\n*\n";
    p4 = p1 * 3;
    cout << p4;

    cout << "\n/\n";
    p4 = p4 / 3;
    cout << p4;

    cout << "\n*=\n";
    p4 = p1 * 4;
    cout << p4;

    cout << "\n/=\n";
    p4 = p4 / 4;
    cout << p4;

    cout << "\np*p(b)\n";
    p4 = p1 * p2;
    cout << p4;

    cout << "\np*p(y)\n";
    p4 = p2 * p1;
    cout << p4;

    cout << "\n[]\n";;
    cout << p4[2];
}
