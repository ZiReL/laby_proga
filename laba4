#include <iostream>
#include <vector>
#include <set>

using namespace std;

template<class T>
class CPoint {
public:
    T  x1, x2, x3;

    bool operator==( const CPoint &p) {
        if ((this->x1 == p.x1) and (this->x2 == p.x2) and (this->x3 == p.x3))
            return true;
        return false;
    }

    bool operator!=( const CPoint &p) {
        return !(this == p);
    }
};

template<class T>
bool equal_to_(T x1, T x2) {
    return x1 == x2;
}

template<class T>
bool not_equal_to_(T x1, T x2) {
    return x1 != x2;
}

template<class T>
bool less_(T x1, T x2) {
    return x1 < x2;
}

template<class T>
bool less_equal_(T x1, T x2) {
    return x1 <= x2;
}

template<class T>
bool greater_(T x1, T x2) {
    return x1 > x2;
}

template<class T>
bool greater_equal_(T x1, T x2) {
    return x1 >= x2;
}

template<class T>  // для целочисленного типа
bool parity_(T x1, T x2) {
    return ((x1 % 2) == (x2 % 2));
}



template<class T, class CIterator>
bool all_of(CIterator begin, CIterator end, const T &n, bool (&func)(T, T)) {
    for (;begin != end; begin++)
        if (!func(*begin, n))
            return false;
    return true;
}

template<class T, class CIterator>
bool any_of(CIterator begin, CIterator end, const T &n, bool (&func)(T, T)) {
    for (;begin != end; begin++)
        if (func(*begin, n))
            return true;
    return false;
}

template<class T, class CIterator>
bool none_of(CIterator begin, CIterator end, const T &n, bool (&func)(T, T)) {
    for (;begin != end; begin++)
        if (func(*begin, n))
            return false;
    return true;
}

template<class T, class CIterator>
bool one_of(CIterator begin, CIterator end, const T &n, bool (&func)(T, T)) {
    int k = 0;
    for (;begin != end; begin++)
        if (func(*begin, n))
            k++;
    if (k == 1)
        return true;
    return false;
}

template<class T, class CIterator>
bool is_sorted(CIterator begin, CIterator end, bool (&func)(T, T)) {
    end--;
    for (;begin != end; begin++)
        if (!func(*begin, *(next(begin))))
            return false;
    return true;
}

template<class T, class CIterator>
bool is_partitioned(CIterator begin, CIterator end, bool (&func)(T, T)) {
    begin++;
    if (func(*(prev(begin)),*begin)) {
        while ((begin != end) and func(*(prev(begin)),*begin))
            begin++;
        if (begin == end)
            return false;
        while (begin != end) {
            if (func(*(prev(begin)), *begin))
                return false;
            begin++;
        }
    }
    else {
        while ((begin != end) and !func(*(prev(begin)),*begin))
            begin++;
        if (begin == end)
            return false;
        while (begin != end) {
            if (!func(*(prev(begin)), *begin))
                return false;
            begin++;
        }
    }
    return true;
}

template<class T, class CIterator>
CIterator find_not(CIterator begin, CIterator end, const T& value) {
    if (begin == end)
        return begin;
    for (;begin != end; begin++)
        if (*begin != value)
            return begin;
    return end;
}

template<class T, class CIterator>
CIterator find_backward(CIterator begin, CIterator end, const T& value) {
    if (begin == end)
        return begin;
    CIterator vsp = end;
    for (;begin != end; begin++)
        if (*begin == value)
            vsp = begin;
    return vsp;
}

template<class T, class CIterator>
bool is_palindrome(CIterator begin, CIterator end, bool (&func)(T, T)) {
    if (begin == end)
        return begin;
    end--;
    while ((begin != end) or (begin != prev(end))) {
        if (!func(*begin, *end))
            return false;
        begin++;
        end--;
    }
    return true;
}

int main() {
    system("chcp 65001");

    vector<int> mas = {1, 2, 3, 2, 1};
    int n;

    set<int> mas2 = {1, 2, 3, 2, 1};

    vector<CPoint<int>> mas3;

    CPoint<int> p = {5, 6, 7};

    n = 7;
    cout << "\n\n1. all_of    true - все элементы удовлетворяют предикату\n";
    cout << all_of(mas.begin(), mas.end(), n, less_) << "\n";

    mas3 = {{5, 7, 8}, {5, 6, 7}};
    cout << "\n2. any_of    true - хотя бы один элемент удовлетворяет предикату\n";
    cout << any_of(mas3.begin(), mas3.end(), p, equal_to_) << "\n";

    n = 5;
    cout << "\n3. none_of   true - все элементы не удовлетворяют предикату\n";
    cout << none_of(mas.begin(), mas.end(), n, greater_equal_<int>) << "\n";

    n = 1;
    cout << "\n4. one_of    true - один элемент удовлетворяют предикату\n";
    cout << one_of(mas.begin(), mas.end(), n, less_equal_) << "\n";

    cout << "\n5. is_sorted   true - все элементы находятся в отсортированном порядке относительно некоторого критерия\n";
    cout << is_sorted(mas2.begin(), mas2.end(), greater_<int>) << "\n";

    mas = {4, 3, 2, 1, 2, 3};
    cout << "\n6. is_partitioned   true - все элементы делятся на удовлетворяющие и не удовлетворяющие некоторому предикату\n";
    cout << is_partitioned(mas.begin(), mas.end(), greater_<int>) << "\n";

    n = 1;
    cout << "\n7. find_not   true - поиск элемента, не равного заданному\n";
    cout << *find_not(mas.begin(), mas.end(), n) << "\n";

    mas = {2, 3, 2, 1, 4};
    n = 7;
    cout << "\n8. find_backward   true - поиск элемента, равного заданному с конца\n";
    cout << *find_backward(mas.begin(), mas.end(), n) << "\n";

    mas = {1, 2, 3, 3, 2, 1};
    cout << "\n9. is_palindrome   true - палиндром\n";
    cout << is_palindrome(mas.begin(), mas.end(), equal_to_<int>) << "\n";
}
// '=' - equal_to_
// '!=' - not_equal_to_
// '>' - greater_
// '<' - less_
// '>=' - greater_equal_
// '<=' - less_equal_
// 'четность' - parity_
